// Code generated by fastssz. DO NOT EDIT.
// Hash: 59f8b3862b646e6b26e3dc3411574c8f206f327453b5ac5ffa7613e2955ab647
// Version: 0.1.3
package types

import (
	ssz "github.com/ferranbt/fastssz"
)

// MarshalSSZ ssz marshals the Checkpoint object
func (c *Checkpoint) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the Checkpoint object to a target array
func (c *Checkpoint) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Root'
	dst = append(dst, c.Root[:]...)

	// Field (1) 'Slot'
	dst = ssz.MarshalUint64(dst, uint64(c.Slot))

	return
}

// UnmarshalSSZ ssz unmarshals the Checkpoint object
func (c *Checkpoint) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 40 {
		return ssz.ErrSize
	}

	// Field (0) 'Root'
	copy(c.Root[:], buf[0:32])

	// Field (1) 'Slot'
	c.Slot = Slot(ssz.UnmarshallUint64(buf[32:40]))

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Checkpoint object
func (c *Checkpoint) SizeSSZ() (size int) {
	size = 40
	return
}

// HashTreeRoot ssz hashes the Checkpoint object
func (c *Checkpoint) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the Checkpoint object with a hasher
func (c *Checkpoint) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Root'
	hh.PutBytes(c.Root[:])

	// Field (1) 'Slot'
	hh.PutUint64(uint64(c.Slot))

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Checkpoint object
func (c *Checkpoint) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(c)
}

// MarshalSSZ ssz marshals the Config object
func (c *Config) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(c)
}

// MarshalSSZTo ssz marshals the Config object to a target array
func (c *Config) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'GenesisTime'
	dst = ssz.MarshalUint64(dst, c.GenesisTime)

	return
}

// UnmarshalSSZ ssz unmarshals the Config object
func (c *Config) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 8 {
		return ssz.ErrSize
	}

	// Field (0) 'GenesisTime'
	c.GenesisTime = ssz.UnmarshallUint64(buf[0:8])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Config object
func (c *Config) SizeSSZ() (size int) {
	size = 8
	return
}

// HashTreeRoot ssz hashes the Config object
func (c *Config) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(c)
}

// HashTreeRootWith ssz hashes the Config object with a hasher
func (c *Config) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'GenesisTime'
	hh.PutUint64(c.GenesisTime)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Config object
func (c *Config) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(c)
}

// MarshalSSZ ssz marshals the Validator object
func (v *Validator) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(v)
}

// MarshalSSZTo ssz marshals the Validator object to a target array
func (v *Validator) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Pubkey'
	dst = append(dst, v.Pubkey[:]...)

	// Field (1) 'Index'
	dst = ssz.MarshalUint64(dst, v.Index)

	return
}

// UnmarshalSSZ ssz unmarshals the Validator object
func (v *Validator) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 60 {
		return ssz.ErrSize
	}

	// Field (0) 'Pubkey'
	copy(v.Pubkey[:], buf[0:52])

	// Field (1) 'Index'
	v.Index = ssz.UnmarshallUint64(buf[52:60])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Validator object
func (v *Validator) SizeSSZ() (size int) {
	size = 60
	return
}

// HashTreeRoot ssz hashes the Validator object
func (v *Validator) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(v)
}

// HashTreeRootWith ssz hashes the Validator object with a hasher
func (v *Validator) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Pubkey'
	hh.PutBytes(v.Pubkey[:])

	// Field (1) 'Index'
	hh.PutUint64(v.Index)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Validator object
func (v *Validator) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(v)
}

// MarshalSSZ ssz marshals the AttestationData object
func (a *AttestationData) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(a)
}

// MarshalSSZTo ssz marshals the AttestationData object to a target array
func (a *AttestationData) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Slot'
	dst = ssz.MarshalUint64(dst, uint64(a.Slot))

	// Field (1) 'Head'
	if dst, err = a.Head.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (2) 'Target'
	if dst, err = a.Target.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (3) 'Source'
	if dst, err = a.Source.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the AttestationData object
func (a *AttestationData) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 128 {
		return ssz.ErrSize
	}

	// Field (0) 'Slot'
	a.Slot = Slot(ssz.UnmarshallUint64(buf[0:8]))

	// Field (1) 'Head'
	if err = a.Head.UnmarshalSSZ(buf[8:48]); err != nil {
		return err
	}

	// Field (2) 'Target'
	if err = a.Target.UnmarshalSSZ(buf[48:88]); err != nil {
		return err
	}

	// Field (3) 'Source'
	if err = a.Source.UnmarshalSSZ(buf[88:128]); err != nil {
		return err
	}

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the AttestationData object
func (a *AttestationData) SizeSSZ() (size int) {
	size = 128
	return
}

// HashTreeRoot ssz hashes the AttestationData object
func (a *AttestationData) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(a)
}

// HashTreeRootWith ssz hashes the AttestationData object with a hasher
func (a *AttestationData) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Slot'
	hh.PutUint64(uint64(a.Slot))

	// Field (1) 'Head'
	if err = a.Head.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (2) 'Target'
	if err = a.Target.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (3) 'Source'
	if err = a.Source.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the AttestationData object
func (a *AttestationData) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(a)
}

// MarshalSSZ ssz marshals the Attestation object
func (a *Attestation) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(a)
}

// MarshalSSZTo ssz marshals the Attestation object to a target array
func (a *Attestation) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'ValidatorID'
	dst = ssz.MarshalUint64(dst, a.ValidatorID)

	// Field (1) 'Data'
	if dst, err = a.Data.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Attestation object
func (a *Attestation) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 136 {
		return ssz.ErrSize
	}

	// Field (0) 'ValidatorID'
	a.ValidatorID = ssz.UnmarshallUint64(buf[0:8])

	// Field (1) 'Data'
	if err = a.Data.UnmarshalSSZ(buf[8:136]); err != nil {
		return err
	}

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Attestation object
func (a *Attestation) SizeSSZ() (size int) {
	size = 136
	return
}

// HashTreeRoot ssz hashes the Attestation object
func (a *Attestation) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(a)
}

// HashTreeRootWith ssz hashes the Attestation object with a hasher
func (a *Attestation) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'ValidatorID'
	hh.PutUint64(a.ValidatorID)

	// Field (1) 'Data'
	if err = a.Data.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Attestation object
func (a *Attestation) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(a)
}

// MarshalSSZ ssz marshals the AggregatedAttestation object
func (a *AggregatedAttestation) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(a)
}

// MarshalSSZTo ssz marshals the AggregatedAttestation object to a target array
func (a *AggregatedAttestation) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(132)

	// Offset (0) 'AggregationBits'
	dst = ssz.WriteOffset(dst, offset)

	// Field (1) 'Data'
	if dst, err = a.Data.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (0) 'AggregationBits'
	if size := len(a.AggregationBits); size > 4096 {
		err = ssz.ErrBytesLengthFn("AggregatedAttestation.AggregationBits", size, 4096)
		return
	}
	dst = append(dst, a.AggregationBits...)

	return
}

// UnmarshalSSZ ssz unmarshals the AggregatedAttestation object
func (a *AggregatedAttestation) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 132 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'AggregationBits'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 != 132 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (1) 'Data'
	if err = a.Data.UnmarshalSSZ(buf[4:132]); err != nil {
		return err
	}

	// Field (0) 'AggregationBits'
	{
		buf = tail[o0:]
		if err = ssz.ValidateBitlist(buf, 4096); err != nil {
			return err
		}
		if cap(a.AggregationBits) == 0 {
			a.AggregationBits = make([]byte, 0, len(buf))
		}
		a.AggregationBits = append(a.AggregationBits, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the AggregatedAttestation object
func (a *AggregatedAttestation) SizeSSZ() (size int) {
	size = 132

	// Field (0) 'AggregationBits'
	size += len(a.AggregationBits)

	return
}

// HashTreeRoot ssz hashes the AggregatedAttestation object
func (a *AggregatedAttestation) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(a)
}

// HashTreeRootWith ssz hashes the AggregatedAttestation object with a hasher
func (a *AggregatedAttestation) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'AggregationBits'
	if len(a.AggregationBits) == 0 {
		err = ssz.ErrEmptyBitlist
		return
	}
	hh.PutBitlist(a.AggregationBits, 4096)

	// Field (1) 'Data'
	if err = a.Data.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the AggregatedAttestation object
func (a *AggregatedAttestation) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(a)
}

// MarshalSSZ ssz marshals the BlockHeader object
func (b *BlockHeader) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BlockHeader object to a target array
func (b *BlockHeader) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Slot'
	dst = ssz.MarshalUint64(dst, uint64(b.Slot))

	// Field (1) 'ProposerIndex'
	dst = ssz.MarshalUint64(dst, b.ProposerIndex)

	// Field (2) 'ParentRoot'
	dst = append(dst, b.ParentRoot[:]...)

	// Field (3) 'StateRoot'
	dst = append(dst, b.StateRoot[:]...)

	// Field (4) 'BodyRoot'
	dst = append(dst, b.BodyRoot[:]...)

	return
}

// UnmarshalSSZ ssz unmarshals the BlockHeader object
func (b *BlockHeader) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 112 {
		return ssz.ErrSize
	}

	// Field (0) 'Slot'
	b.Slot = Slot(ssz.UnmarshallUint64(buf[0:8]))

	// Field (1) 'ProposerIndex'
	b.ProposerIndex = ssz.UnmarshallUint64(buf[8:16])

	// Field (2) 'ParentRoot'
	copy(b.ParentRoot[:], buf[16:48])

	// Field (3) 'StateRoot'
	copy(b.StateRoot[:], buf[48:80])

	// Field (4) 'BodyRoot'
	copy(b.BodyRoot[:], buf[80:112])

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the BlockHeader object
func (b *BlockHeader) SizeSSZ() (size int) {
	size = 112
	return
}

// HashTreeRoot ssz hashes the BlockHeader object
func (b *BlockHeader) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BlockHeader object with a hasher
func (b *BlockHeader) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Slot'
	hh.PutUint64(uint64(b.Slot))

	// Field (1) 'ProposerIndex'
	hh.PutUint64(b.ProposerIndex)

	// Field (2) 'ParentRoot'
	hh.PutBytes(b.ParentRoot[:])

	// Field (3) 'StateRoot'
	hh.PutBytes(b.StateRoot[:])

	// Field (4) 'BodyRoot'
	hh.PutBytes(b.BodyRoot[:])

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BlockHeader object
func (b *BlockHeader) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the BlockBody object
func (b *BlockBody) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BlockBody object to a target array
func (b *BlockBody) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(4)

	// Offset (0) 'Attestations'
	dst = ssz.WriteOffset(dst, offset)

	// Field (0) 'Attestations'
	if size := len(b.Attestations); size > 4096 {
		err = ssz.ErrListTooBigFn("BlockBody.Attestations", size, 4096)
		return
	}
	{
		offset = 4 * len(b.Attestations)
		for ii := 0; ii < len(b.Attestations); ii++ {
			dst = ssz.WriteOffset(dst, offset)
			offset += b.Attestations[ii].SizeSSZ()
		}
	}
	for ii := 0; ii < len(b.Attestations); ii++ {
		if dst, err = b.Attestations[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	return
}

// UnmarshalSSZ ssz unmarshals the BlockBody object
func (b *BlockBody) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 4 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Attestations'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 != 4 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (0) 'Attestations'
	{
		buf = tail[o0:]
		num, err := ssz.DecodeDynamicLength(buf, 4096)
		if err != nil {
			return err
		}
		b.Attestations = make([]AggregatedAttestation, num)
		err = ssz.UnmarshalDynamic(buf, num, func(indx int, buf []byte) (err error) {
			if err = b.Attestations[indx].UnmarshalSSZ(buf); err != nil {
				return err
			}
			return nil
		})
		if err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the BlockBody object
func (b *BlockBody) SizeSSZ() (size int) {
	size = 4

	// Field (0) 'Attestations'
	for ii := 0; ii < len(b.Attestations); ii++ {
		size += 4
		size += b.Attestations[ii].SizeSSZ()
	}

	return
}

// HashTreeRoot ssz hashes the BlockBody object
func (b *BlockBody) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BlockBody object with a hasher
func (b *BlockBody) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Attestations'
	{
		subIndx := hh.Index()
		num := uint64(len(b.Attestations))
		if num > 4096 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range b.Attestations {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 4096)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BlockBody object
func (b *BlockBody) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the Block object
func (b *Block) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the Block object to a target array
func (b *Block) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(84)

	// Field (0) 'Slot'
	dst = ssz.MarshalUint64(dst, uint64(b.Slot))

	// Field (1) 'ProposerIndex'
	dst = ssz.MarshalUint64(dst, b.ProposerIndex)

	// Field (2) 'ParentRoot'
	dst = append(dst, b.ParentRoot[:]...)

	// Field (3) 'StateRoot'
	dst = append(dst, b.StateRoot[:]...)

	// Offset (4) 'Body'
	dst = ssz.WriteOffset(dst, offset)

	// Field (4) 'Body'
	if dst, err = b.Body.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Block object
func (b *Block) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 84 {
		return ssz.ErrSize
	}

	tail := buf
	var o4 uint64

	// Field (0) 'Slot'
	b.Slot = Slot(ssz.UnmarshallUint64(buf[0:8]))

	// Field (1) 'ProposerIndex'
	b.ProposerIndex = ssz.UnmarshallUint64(buf[8:16])

	// Field (2) 'ParentRoot'
	copy(b.ParentRoot[:], buf[16:48])

	// Field (3) 'StateRoot'
	copy(b.StateRoot[:], buf[48:80])

	// Offset (4) 'Body'
	if o4 = ssz.ReadOffset(buf[80:84]); o4 > size {
		return ssz.ErrOffset
	}

	if o4 != 84 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (4) 'Body'
	{
		buf = tail[o4:]
		if err = b.Body.UnmarshalSSZ(buf); err != nil {
			return err
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Block object
func (b *Block) SizeSSZ() (size int) {
	size = 84

	// Field (4) 'Body'
	size += b.Body.SizeSSZ()

	return
}

// HashTreeRoot ssz hashes the Block object
func (b *Block) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the Block object with a hasher
func (b *Block) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Slot'
	hh.PutUint64(uint64(b.Slot))

	// Field (1) 'ProposerIndex'
	hh.PutUint64(b.ProposerIndex)

	// Field (2) 'ParentRoot'
	hh.PutBytes(b.ParentRoot[:])

	// Field (3) 'StateRoot'
	hh.PutBytes(b.StateRoot[:])

	// Field (4) 'Body'
	if err = b.Body.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Block object
func (b *Block) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}

// MarshalSSZ ssz marshals the State object
func (s *State) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the State object to a target array
func (s *State) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(228)

	// Field (0) 'Config'
	if dst, err = s.Config.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Slot'
	dst = ssz.MarshalUint64(dst, uint64(s.Slot))

	// Field (2) 'LatestBlockHeader'
	if dst, err = s.LatestBlockHeader.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (3) 'LatestJustified'
	if dst, err = s.LatestJustified.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (4) 'LatestFinalized'
	if dst, err = s.LatestFinalized.MarshalSSZTo(dst); err != nil {
		return
	}

	// Offset (5) 'HistoricalRoots'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.HistoricalRoots) * 32

	// Offset (6) 'JustifiedSlots'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.JustifiedSlots)

	// Offset (7) 'Validators'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.Validators) * 60

	// Offset (8) 'JustificationRoots'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(s.JustificationRoots) * 32

	// Offset (9) 'JustificationVotes'
	dst = ssz.WriteOffset(dst, offset)

	// Field (5) 'HistoricalRoots'
	if size := len(s.HistoricalRoots); size > 262144 {
		err = ssz.ErrListTooBigFn("State.HistoricalRoots", size, 262144)
		return
	}
	for ii := 0; ii < len(s.HistoricalRoots); ii++ {
		dst = append(dst, s.HistoricalRoots[ii][:]...)
	}

	// Field (6) 'JustifiedSlots'
	if size := len(s.JustifiedSlots); size > 262144 {
		err = ssz.ErrBytesLengthFn("State.JustifiedSlots", size, 262144)
		return
	}
	dst = append(dst, s.JustifiedSlots...)

	// Field (7) 'Validators'
	if size := len(s.Validators); size > 4096 {
		err = ssz.ErrListTooBigFn("State.Validators", size, 4096)
		return
	}
	for ii := 0; ii < len(s.Validators); ii++ {
		if dst, err = s.Validators[ii].MarshalSSZTo(dst); err != nil {
			return
		}
	}

	// Field (8) 'JustificationRoots'
	if size := len(s.JustificationRoots); size > 262144 {
		err = ssz.ErrListTooBigFn("State.JustificationRoots", size, 262144)
		return
	}
	for ii := 0; ii < len(s.JustificationRoots); ii++ {
		dst = append(dst, s.JustificationRoots[ii][:]...)
	}

	// Field (9) 'JustificationVotes'
	if size := len(s.JustificationVotes); size > 1073741824 {
		err = ssz.ErrBytesLengthFn("State.JustificationVotes", size, 1073741824)
		return
	}
	dst = append(dst, s.JustificationVotes...)

	return
}

// UnmarshalSSZ ssz unmarshals the State object
func (s *State) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 228 {
		return ssz.ErrSize
	}

	tail := buf
	var o5, o6, o7, o8, o9 uint64

	// Field (0) 'Config'
	if err = s.Config.UnmarshalSSZ(buf[0:8]); err != nil {
		return err
	}

	// Field (1) 'Slot'
	s.Slot = Slot(ssz.UnmarshallUint64(buf[8:16]))

	// Field (2) 'LatestBlockHeader'
	if err = s.LatestBlockHeader.UnmarshalSSZ(buf[16:128]); err != nil {
		return err
	}

	// Field (3) 'LatestJustified'
	if err = s.LatestJustified.UnmarshalSSZ(buf[128:168]); err != nil {
		return err
	}

	// Field (4) 'LatestFinalized'
	if err = s.LatestFinalized.UnmarshalSSZ(buf[168:208]); err != nil {
		return err
	}

	// Offset (5) 'HistoricalRoots'
	if o5 = ssz.ReadOffset(buf[208:212]); o5 > size {
		return ssz.ErrOffset
	}

	if o5 != 228 {
		return ssz.ErrInvalidVariableOffset
	}

	// Offset (6) 'JustifiedSlots'
	if o6 = ssz.ReadOffset(buf[212:216]); o6 > size || o5 > o6 {
		return ssz.ErrOffset
	}

	// Offset (7) 'Validators'
	if o7 = ssz.ReadOffset(buf[216:220]); o7 > size || o6 > o7 {
		return ssz.ErrOffset
	}

	// Offset (8) 'JustificationRoots'
	if o8 = ssz.ReadOffset(buf[220:224]); o8 > size || o7 > o8 {
		return ssz.ErrOffset
	}

	// Offset (9) 'JustificationVotes'
	if o9 = ssz.ReadOffset(buf[224:228]); o9 > size || o8 > o9 {
		return ssz.ErrOffset
	}

	// Field (5) 'HistoricalRoots'
	{
		buf = tail[o5:o6]
		num, err := ssz.DivideInt2(len(buf), 32, 262144)
		if err != nil {
			return err
		}
		s.HistoricalRoots = make([]Root, num)
		for ii := 0; ii < num; ii++ {
			copy(s.HistoricalRoots[ii][:], buf[ii*32:(ii+1)*32])
		}
	}

	// Field (6) 'JustifiedSlots'
	{
		buf = tail[o6:o7]
		if err = ssz.ValidateBitlist(buf, 262144); err != nil {
			return err
		}
		if cap(s.JustifiedSlots) == 0 {
			s.JustifiedSlots = make([]byte, 0, len(buf))
		}
		s.JustifiedSlots = append(s.JustifiedSlots, buf...)
	}

	// Field (7) 'Validators'
	{
		buf = tail[o7:o8]
		num, err := ssz.DivideInt2(len(buf), 60, 4096)
		if err != nil {
			return err
		}
		s.Validators = make([]Validator, num)
		for ii := 0; ii < num; ii++ {
			if err = s.Validators[ii].UnmarshalSSZ(buf[ii*60 : (ii+1)*60]); err != nil {
				return err
			}
		}
	}

	// Field (8) 'JustificationRoots'
	{
		buf = tail[o8:o9]
		num, err := ssz.DivideInt2(len(buf), 32, 262144)
		if err != nil {
			return err
		}
		s.JustificationRoots = make([]Root, num)
		for ii := 0; ii < num; ii++ {
			copy(s.JustificationRoots[ii][:], buf[ii*32:(ii+1)*32])
		}
	}

	// Field (9) 'JustificationVotes'
	{
		buf = tail[o9:]
		if err = ssz.ValidateBitlist(buf, 1073741824); err != nil {
			return err
		}
		if cap(s.JustificationVotes) == 0 {
			s.JustificationVotes = make([]byte, 0, len(buf))
		}
		s.JustificationVotes = append(s.JustificationVotes, buf...)
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the State object
func (s *State) SizeSSZ() (size int) {
	size = 228

	// Field (5) 'HistoricalRoots'
	size += len(s.HistoricalRoots) * 32

	// Field (6) 'JustifiedSlots'
	size += len(s.JustifiedSlots)

	// Field (7) 'Validators'
	size += len(s.Validators) * 60

	// Field (8) 'JustificationRoots'
	size += len(s.JustificationRoots) * 32

	// Field (9) 'JustificationVotes'
	size += len(s.JustificationVotes)

	return
}

// HashTreeRoot ssz hashes the State object
func (s *State) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the State object with a hasher
func (s *State) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Config'
	if err = s.Config.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Slot'
	hh.PutUint64(uint64(s.Slot))

	// Field (2) 'LatestBlockHeader'
	if err = s.LatestBlockHeader.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (3) 'LatestJustified'
	if err = s.LatestJustified.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (4) 'LatestFinalized'
	if err = s.LatestFinalized.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (5) 'HistoricalRoots'
	{
		if size := len(s.HistoricalRoots); size > 262144 {
			err = ssz.ErrListTooBigFn("State.HistoricalRoots", size, 262144)
			return
		}
		subIndx := hh.Index()
		for _, i := range s.HistoricalRoots {
			hh.Append(i[:])
		}
		numItems := uint64(len(s.HistoricalRoots))
		hh.MerkleizeWithMixin(subIndx, numItems, 262144)
	}

	// Field (6) 'JustifiedSlots'
	if len(s.JustifiedSlots) == 0 {
		err = ssz.ErrEmptyBitlist
		return
	}
	hh.PutBitlist(s.JustifiedSlots, 262144)

	// Field (7) 'Validators'
	{
		subIndx := hh.Index()
		num := uint64(len(s.Validators))
		if num > 4096 {
			err = ssz.ErrIncorrectListSize
			return
		}
		for _, elem := range s.Validators {
			if err = elem.HashTreeRootWith(hh); err != nil {
				return
			}
		}
		hh.MerkleizeWithMixin(subIndx, num, 4096)
	}

	// Field (8) 'JustificationRoots'
	{
		if size := len(s.JustificationRoots); size > 262144 {
			err = ssz.ErrListTooBigFn("State.JustificationRoots", size, 262144)
			return
		}
		subIndx := hh.Index()
		for _, i := range s.JustificationRoots {
			hh.Append(i[:])
		}
		numItems := uint64(len(s.JustificationRoots))
		hh.MerkleizeWithMixin(subIndx, numItems, 262144)
	}

	// Field (9) 'JustificationVotes'
	if len(s.JustificationVotes) == 0 {
		err = ssz.ErrEmptyBitlist
		return
	}
	hh.PutBitlist(s.JustificationVotes, 1073741824)

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the State object
func (s *State) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}
