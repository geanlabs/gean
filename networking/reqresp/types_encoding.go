// Code generated by fastssz. DO NOT EDIT.
// Hash: 214fde7d508741e7395dad4847618c5f7302c692e0ffc22edc3563a235aeba2e
// Version: 0.1.3
package reqresp

import (
	ssz "github.com/ferranbt/fastssz"
	"github.com/devylongs/gean/types"
)

// MarshalSSZ ssz marshals the Status object
func (s *Status) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(s)
}

// MarshalSSZTo ssz marshals the Status object to a target array
func (s *Status) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf

	// Field (0) 'Finalized'
	if dst, err = s.Finalized.MarshalSSZTo(dst); err != nil {
		return
	}

	// Field (1) 'Head'
	if dst, err = s.Head.MarshalSSZTo(dst); err != nil {
		return
	}

	return
}

// UnmarshalSSZ ssz unmarshals the Status object
func (s *Status) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size != 80 {
		return ssz.ErrSize
	}

	// Field (0) 'Finalized'
	if err = s.Finalized.UnmarshalSSZ(buf[0:40]); err != nil {
		return err
	}

	// Field (1) 'Head'
	if err = s.Head.UnmarshalSSZ(buf[40:80]); err != nil {
		return err
	}

	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the Status object
func (s *Status) SizeSSZ() (size int) {
	size = 80
	return
}

// HashTreeRoot ssz hashes the Status object
func (s *Status) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(s)
}

// HashTreeRootWith ssz hashes the Status object with a hasher
func (s *Status) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Finalized'
	if err = s.Finalized.HashTreeRootWith(hh); err != nil {
		return
	}

	// Field (1) 'Head'
	if err = s.Head.HashTreeRootWith(hh); err != nil {
		return
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the Status object
func (s *Status) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(s)
}

// MarshalSSZ ssz marshals the BlocksByRootRequest object
func (b *BlocksByRootRequest) MarshalSSZ() ([]byte, error) {
	return ssz.MarshalSSZ(b)
}

// MarshalSSZTo ssz marshals the BlocksByRootRequest object to a target array
func (b *BlocksByRootRequest) MarshalSSZTo(buf []byte) (dst []byte, err error) {
	dst = buf
	offset := int(4)

	// Offset (0) 'Roots'
	dst = ssz.WriteOffset(dst, offset)
	offset += len(b.Roots) * 32

	// Field (0) 'Roots'
	if size := len(b.Roots); size > 1024 {
		err = ssz.ErrListTooBigFn("BlocksByRootRequest.Roots", size, 1024)
		return
	}
	for ii := 0; ii < len(b.Roots); ii++ {
		dst = append(dst, b.Roots[ii][:]...)
	}

	return
}

// UnmarshalSSZ ssz unmarshals the BlocksByRootRequest object
func (b *BlocksByRootRequest) UnmarshalSSZ(buf []byte) error {
	var err error
	size := uint64(len(buf))
	if size < 4 {
		return ssz.ErrSize
	}

	tail := buf
	var o0 uint64

	// Offset (0) 'Roots'
	if o0 = ssz.ReadOffset(buf[0:4]); o0 > size {
		return ssz.ErrOffset
	}

	if o0 < 4 {
		return ssz.ErrInvalidVariableOffset
	}

	// Field (0) 'Roots'
	{
		buf = tail[o0:]
		num, err := ssz.DivideInt2(len(buf), 32, 1024)
		if err != nil {
			return err
		}
		b.Roots = make([]types.Root, num)
		for ii := 0; ii < num; ii++ {
			copy(b.Roots[ii][:], buf[ii*32:(ii+1)*32])
		}
	}
	return err
}

// SizeSSZ returns the ssz encoded size in bytes for the BlocksByRootRequest object
func (b *BlocksByRootRequest) SizeSSZ() (size int) {
	size = 4

	// Field (0) 'Roots'
	size += len(b.Roots) * 32

	return
}

// HashTreeRoot ssz hashes the BlocksByRootRequest object
func (b *BlocksByRootRequest) HashTreeRoot() ([32]byte, error) {
	return ssz.HashWithDefaultHasher(b)
}

// HashTreeRootWith ssz hashes the BlocksByRootRequest object with a hasher
func (b *BlocksByRootRequest) HashTreeRootWith(hh ssz.HashWalker) (err error) {
	indx := hh.Index()

	// Field (0) 'Roots'
	{
		if size := len(b.Roots); size > 1024 {
			err = ssz.ErrListTooBigFn("BlocksByRootRequest.Roots", size, 1024)
			return
		}
		subIndx := hh.Index()
		for _, i := range b.Roots {
			hh.Append(i[:])
		}
		hh.Merkleize(subIndx)
	}

	hh.Merkleize(indx)
	return
}

// GetTree ssz hashes the BlocksByRootRequest object
func (b *BlocksByRootRequest) GetTree() (*ssz.Node, error) {
	return ssz.ProofTree(b)
}
